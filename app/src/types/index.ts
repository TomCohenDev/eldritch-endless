// Wiki data types (from eldritch_horror_data.json)
// Renamed interface to force cache bust
export interface WikiPage {
  title: string;
  pageId: number;
  categories: string[];
  infobox: Record<string, string>;
  cardData: Record<string, string>;
  sections: Record<string, string>;
  links: string[];
  templates: string[];
  fullText: string;
  rawWikitext: string;
}

export interface GameData {
  metadata: {
    source: string;
    scrapedAt: string;
    version: string;
    totalPages: number;
    stats: Record<string, number>;
  };
  categories: {
    investigators: WikiPage[];
    ancientOnes: WikiPage[];
    monsters: WikiPage[];
    epicMonsters: WikiPage[];
    assets: WikiPage[];
    uniqueAssets: WikiPage[];
    artifacts: WikiPage[];
    spells: WikiPage[];
    conditions: WikiPage[];
    encounters: {
      general: WikiPage[];
      location: WikiPage[];
      research: WikiPage[];
      otherWorld: WikiPage[];
      expedition: WikiPage[];
      mysticRuins: WikiPage[];
      dreamQuest: WikiPage[];
      devastation: WikiPage[];
      special: WikiPage[];
      combat: WikiPage[];
      other: WikiPage[];
    };
    mythos: WikiPage[];
    mysteries: WikiPage[];
    preludes: WikiPage[];
    adventures: WikiPage[];
    personalStories: WikiPage[];
    gameSets: WikiPage[];
    gameBoards: WikiPage[];
    mechanics: WikiPage[];
    other: WikiPage[];
  };
  allPages: Record<string, WikiPage>;
}

export type AncientOneDifficulty = "Low" | "Medium" | "High";

export interface AncientOneSetupMeta {
  difficulty: AncientOneDifficulty;
  startingDoom: number;
  mythosDeckSize: number;
  mysteries: string;
  notes: string;
  set: string;
  requiresSideBoard: "Antarctica" | "Dreamlands" | "Egypt" | null;
}

// Some screens will attach setup info onto the WikiPage at runtime.
export type AncientOnePage = WikiPage & { setup?: AncientOneSetupMeta };

// Game state types
export type GamePhase =
  | "setup"
  | "action"
  | "encounter"
  | "mythos"
  | "resolution";

// Location on the world map (named cities or numbered spaces)
export interface MapLocation {
  id: string; // e.g. "London", "Space 13"
  name: string; // Display name: "London", "Arctic Ocean (Space 13)"
  type: "City" | "Sea" | "Wilderness";
  realWorld?: string; // e.g. "Franz Josef Land, Russia"
}

// Action types available during Action Phase
export type ActionType =
  | "travel" // Move to an adjacent space
  | "rest" // Recover 1 Health and 1 Sanity
  | "trade" // Exchange assets/clues with investigator on same space
  | "prepare_travel" // Acquire a Ship or Train ticket
  | "acquire_assets" // Roll Influence to gain assets from reserve
  | "component" // Use a component action (focus, special ability, etc.)
  | "local_action"; // Location-specific action (city action)

// Record of a single action taken by an investigator
export interface ActionRecord {
  id: string;
  playerId: string;
  actionType: ActionType;
  timestamp: number;
  round: number;
  details: {
    fromLocation?: string;
    toLocation?: string;
    healthChange?: number;
    sanityChange?: number;
    itemsTraded?: string[];
    ticketAcquired?: "ship" | "train";
    assetsAcquired?: string[];
    componentUsed?: string;
    description?: string; // Free-form for context
  };
}

export interface Player {
  id: string;
  name: string;
  investigator: WikiPage | null;
  health: number;
  sanity: number;
  clues: number;
  focus: number;
  conditions: string[];
  assets: string[];
  location: string;

  // Action phase tracking
  actionsRemaining: number; // Starts at 2 each Action Phase
  shipTickets: number;
  trainTickets: number;
}

export interface NarrativeEvent {
  id: string;
  timestamp: number;
  type: "encounter" | "mythos" | "story" | "decision" | "outcome";
  title: string;
  content: string;
  playerIds?: string[];
  outcome?: "pass" | "fail" | "neutral";
  choices?: NarrativeChoice[];
}

export interface NarrativeChoice {
  id: string;
  label: string;
  description?: string;
}

// Plot context generated by AI at game start
export interface InvestigatorThread {
  playerId: string;
  personalStakes: string; // Why THIS investigator must stop it
  connectionToThreat: string; // How their backstory ties in
  potentialArc: string; // Character growth possibility
}

export interface PlotContext {
  // Core narrative
  premise: string; // Opening situation (2-3 sentences)
  currentAct: "rising" | "confrontation" | "climax" | "resolution";

  // Threat context
  ancientOneMotivation: string; // Why the Ancient One is awakening
  cultistAgenda: string; // What forces work against investigators
  cosmicThreat: string; // The stakes if they fail

  // Investigator threads
  investigatorThreads: InvestigatorThread[];

  // Flexible narrative seeds
  mysteryHooks: string[]; // Potential plot directions
  locationSignificance: Record<string, string>; // Why certain places matter

  // Branching possibilities
  possibleOutcomes: {
    victory: string; // What happens if investigators win
    defeat: string; // What happens if Ancient One awakens
    pyrrhicVictory: string; // Win at great cost scenario
  };

  // Dynamic tracking
  currentTension: number; // 0-10 scale
  activeThemes: string[]; // Horror themes in play
  majorPlotPoints: string[]; // Key events that have occurred
}

// API request/response types for plot generation
export interface AncientOneContext {
  name: string;
  epithet?: string;
  shortDescription?: string;
  lore: string;
  abilities: string;
  mysteries: string[];
  researchEncounters: string;
  defeatCondition: string;
  awakeningTitle?: string;
  awakeningEffects?: string;
  finalMystery?: string;
  appearance?: string;
  residence?: string;
  disposition?: string;
  antagonists?: string;
  source?: string;
  cultistInfo?: string;
  difficulty?: string;
  startingDoom?: number;
  mythosDeckSize?: number;
  set?: string;
  setupInstructions?: string;
  mythosDeck?: {
    stage1: { green: string; yellow: string; blue: string };
    stage2: { green: string; yellow: string; blue: string };
    stage3: { green: string; yellow: string; blue: string };
  };
  mysteryNames?: string[];
  researchEncounterDetails?: ResearchEncounterDetails;
  mysteryDetails?: MysteryDetail[];
}

export interface InvestigatorContext {
  name: string;
  profession: string;
  biography: string;
  abilities: string;
  personalStory: string;
  startingLocation: string;
}

export interface GeneratePlotRequest {
  sessionId: string;
  ancientOne: AncientOneContext;
  investigators: InvestigatorContext[];
  playerCount: number;
  startingDoom: number;
}

// Helper to create empty plot context (fallback)
export function createEmptyPlotContext(): PlotContext {
  return {
    premise: "",
    currentAct: "rising",
    ancientOneMotivation: "",
    cultistAgenda: "",
    cosmicThreat: "",
    investigatorThreads: [],
    mysteryHooks: [],
    locationSignificance: {},
    possibleOutcomes: {
      victory: "",
      defeat: "",
      pyrrhicVictory: "",
    },
    currentTension: 3,
    activeThemes: [],
    majorPlotPoints: [],
  };
}

export interface GameState {
  // Session info
  sessionId: string;
  createdAt: number;
  lastUpdatedAt: number;

  // Game setup
  playerCount: number;
  players: Player[];
  ancientOne: WikiPage | null;

  // Game progress
  phase: GamePhase;
  round: number;
  doom: number;
  maxDoom: number;

  // Action phase tracking
  activePlayerIndex: number; // Which player is currently taking actions
  actionHistory: ActionRecord[]; // Full history of all actions taken (for AI context)

  // Narrative tracking
  narrativeLog: NarrativeEvent[];
  currentEncounter: NarrativeEvent | null;

  // Story context for AI (generated at game start, evolves during play)
  plotContext: PlotContext | null;
}

// Simple fallback UUID generator
function generateUUID() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    try {
      return crypto.randomUUID();
    } catch (e) {
      // Fallback if randomUUID fails (e.g. insecure context in some browsers)
    }
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0;
    const v = c === "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}

// Initial/empty state factory
export function createInitialGameState(): GameState {
  return {
    sessionId: generateUUID(),
    createdAt: Date.now(),
    lastUpdatedAt: Date.now(),
    playerCount: 1,
    players: [],
    ancientOne: null,
    phase: "setup",
    round: 1,
    doom: 0,
    maxDoom: 15,
    activePlayerIndex: 0,
    actionHistory: [],
    narrativeLog: [],
    currentEncounter: null,
    plotContext: null,
  };
}
